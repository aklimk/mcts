#[global_allocator]
static GLOBAL: mimalloc::MiMalloc = mimalloc::MiMalloc;

use mcts::chess_env::ChessState;
use mcts::mcts::MCTSTree;
use std::fs;
use chess::{ChessMove, Rank, File, Piece};


/// Converts a chess action to a simplified version of SAN.
///
/// Implements the basics of SAN without considering taking,
/// piece conflics or promotion changes to the basic format.
fn action_to_string(game_state: ChessState, action: &ChessMove) -> String {
    let src_piece = match game_state.board.piece_on(action.get_dest()).unwrap() {
        Piece::Pawn => "", Piece::Knight => "n", Piece::Bishop => "b", Piece::Rook => "r",
        Piece::Queen => "q", Piece::King => "k"
    }.to_string();
    
    let dest_file = match action.get_dest().get_file() {
        File::A => "a", File::B => "b", File::C => "c", File::D => "d",
        File::E => "e", File::F => "f", File::G => "g", File::H => "h"
    }.to_string();
    
    let dest_rank = match action.get_dest().get_rank() {
        Rank::First => "1", Rank::Second => "2", Rank::Third => "3", Rank::Fourth => "4",
        Rank::Fifth => "5", Rank::Sixth => "6", Rank::Seventh => "7", Rank::Eighth => "8"
    }.to_string();

    return src_piece + &dest_file + &dest_rank;
}  


/// Tests the MCTS engine against a selection of chess puzzles.
///
/// The puzzles contain decicive win situations or large material
/// advantages that should be easy to pick up on. The test is only
/// passed if every puzzle is correctly solved.
///
/// The puzzle file is structured with one puzzle per line,
/// with each line containing the puzzle FEN position and 
/// comma delimited solution. The FEN string and solution are
/// delimited by a colon (:).
///
/// <div class="warning"> The method passed parsed contents from
/// the puzzles_and_solutions.txt file to the chess FEN parsing
/// module. The safety of this parsing from abitrary code execution
/// is not garunteed. </div>
#[test]
fn test_mcts() {
    let runs = 500000;

    // Used as a method to achieve relative pathing to the project root dir.
    let manifest_dir = std::env::var("CARGO_MANIFEST_DIR").expect("Coult not find project Root.");
    
    let contents = fs::read_to_string(
        manifest_dir.clone() + "/tests/puzzles_and_solutions.txt"
    ).expect("Coult not read chess puzzles file.");
    let lines: Vec<&str> = contents.split("\n").collect();

    // Seperates puzzle file lines into position and solution.
    let mut lines_parts: Vec<Vec<&str>> = Vec::new();
    for line in lines {
        // Detection of invalid or comment lines is done by checking if there are two 
        // components seperated by a colon delimiter. This can lead to inavlid lines 
        // being detected as valid if the puzzles file is improperly formatted.
        let line_parts: Vec<&str> = line.split(":").collect();
        if line_parts.len() == 2 {
            lines_parts.push(line_parts);
        }
    }

    // Trim positions and solutions to protect against whitespaces.
    for i in 0..lines_parts.len() {
        lines_parts[i][0] = lines_parts[i][0].trim();
        lines_parts[i][1] = lines_parts[i][1].trim();
    }

    // Go through each puzzle and check if the MCTS solution is correct.
    let mut wrong = 0;
    for i in 0..lines_parts.len() {
        let mut tree = MCTSTree::<ChessMove, ChessState>::with_capacity(
            10000000, // Tree size estimate.
            None, // Random seed.
            lines_parts[i][0].to_string(), // Starting position.
            30 // Children per node estimate.
        );
        
        // Perform `runs` amount of MCTS iterations.
        for _j in 0..runs {
            let select = tree.select(0, None);
            let expand = tree.expand(select);
            let simulate = tree.simulate(expand);
            tree.backpropagate(expand, simulate);
        }

        // Optimal path generated by the MCTS, in terms of tree indexes. 
        // Ignores exploration by setting exploration factor to 0.
        let path_raw = tree.trace_path( tree.select(0, Some(0.0))); 

        // Path mapped to UCI chess moves.
        let path: Vec<String> = path_raw.into_iter().map(
            |index| action_to_string(
                tree.arena[index].game_state.clone(), // Get chess position of the node.
                &tree.arena[index].game_state.last_move
                    .expect("No last move.") // Get the move that created the node's position.
            )
        ).collect();

        // Read the comma delimited solution.
        let ground_truth: Vec<String> = lines_parts[i][1]
            .split(",")
            .map(|str| str.to_string())
            .collect();

        println!("{:?}, {:?}", path, ground_truth);

        if path != ground_truth {
            wrong += 1;
        }
    }
    
    println!("Wrong: {}", wrong);
    assert!(wrong == 0);
}
