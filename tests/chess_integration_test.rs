#[global_allocator]
static GLOBAL: mimalloc::MiMalloc = mimalloc::MiMalloc;

use mcts::chess_env::ChessState;
use mcts::mcts::MCTSTree;
use std::fs;
use chess::{ChessMove, Rank, File, Piece};

// Convert chess action to SAN notation.
fn action_to_string(game_state: ChessState, action: &ChessMove) -> String {
    let src_piece = match game_state.board.piece_on(action.get_dest()).expect("no piece on dest") {
        Piece::Pawn => "", Piece::Knight => "n", Piece::Bishop => "b", Piece::Rook => "r",
        Piece::Queen => "q", Piece::King => "k"
    }.to_string();
    let dest_file = match action.get_dest().get_file() {
        File::A => "a", File::B => "b", File::C => "c", File::D => "d",
        File::E => "e", File::F => "f", File::G => "g", File::H => "h"
    }.to_string();
    let dest_rank = match action.get_dest().get_rank() {
        Rank::First => "1", Rank::Second => "2", Rank::Third => "3", Rank::Fourth => "4",
        Rank::Fifth => "5", Rank::Sixth => "6", Rank::Seventh => "7", Rank::Eighth => "8"
    }.to_string();

    return src_piece + &dest_file + &dest_rank;
}  

/// Test to see if MCTS finds the optimal moves.
/// Within a selection of puzzles.
#[test]
fn test_mcts() {
    // Read starting fens and optimal moves from the puzzles_and_solution text file.
    let runs = 500000;
    let manifest_dir = std::env::var("CARGO_MANIFEST_DIR").expect("no manifest dir");
    let contents = fs::read_to_string(manifest_dir.clone() + "/tests/puzzles_and_solutions.txt").expect("read failed");
    let contents_split: Vec<&str> = contents.split("\n").collect();
    let mut contents_split_parts: Vec<Vec<&str>> = Vec::new();
    for line in contents_split {
        contents_split_parts.push(line.split(":").collect());
    }
    for i in 0..contents_split_parts.len() {
        contents_split_parts[i][0] = contents_split_parts[i][0].trim();
        contents_split_parts[i][1] = contents_split_parts[i][1].trim();
    }

    // Go through each fen and check if the MCTS is optimal
    let mut wrong = 0;
    
    for i in 0..contents_split_parts.len() {
        if contents_split_parts[i][0].chars().nth(0).unwrap() == '#' {
            continue;
        }
        print!("\n");
        let mut tree = MCTSTree::<ChessMove, ChessState>::with_capacity(10000000, Some(444), contents_split_parts[i][0].to_string(), 30);
        println!("{}", tree.arena[0].game_state.board);
        // Perform `runs` amount of MCTS
        for _j in 0..runs {
            let select = tree.select(0, None);
            let expand = tree.expand(select);
            let simulate = tree.simulate(expand);
            tree.backpropagate(expand, simulate);
        }

        // optimal path generated by the MCTS, in terms of tree indexes. Ignores exploration by setting exploration factor to 0.
        let path_raw = tree.trace_path( tree.select(0, Some(0.0))); 

        // path mapped to UCI chess moves.
        let path: Vec<String> = path_raw.into_iter().map(
            |index| action_to_string(tree.arena[index].game_state.clone(), &tree.arena[index].game_state.last_move.expect("no last move"))
        ).collect();

        let ground_truth: Vec<String> = contents_split_parts[i][1].replace(",", "").split(" ").map(|str| str.to_string()).collect();

        println!("{:?}, {:?}", path, ground_truth);
        if path.len() != ground_truth.len() {
            wrong += 1;
        }
        else {
            if path[0..ground_truth.len()] != ground_truth {
                wrong += 1;
            }
        }
    }
    
    println!("Wrong: {}", wrong);
    assert!(wrong == 0);
}
